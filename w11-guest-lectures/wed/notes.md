## Why Programming? What Next?

For our last lecture, let's just have some fun.

--

These are things that are important to my personal journey
as a programmer and I'd like to share them with you.

--

### Motivations

1. The magic of computers for me has always been that they're interactive, alive.
   > Marvin Minsky, "Why Programming Is a Good Medium for Expressing Poorly-Understood and Sloppily-Formulated Ideas"

--

2. I want this in programming but our tools (and **systems**) suck!
   > See anything tweeted by @garybernhardt, Alan Perlis quotes, etc.

--

3. Additionally, software never is really a clean slate. Everything we do is additive,
   building on years and years of prior code. Meaning we don't know what's happening anymore.
   > See: STEPS project, Towards Readable Programs, etc.

---

## Why Programming? What Next?

### Passions (i.e. Beliefs)

4. This is why I've become so attached to the Lisp and Smalltalk machines of yore and am
   fascinated by the 70s. It was a time when we were still free to rethink computing *as a whole*.
   > See: Programming Languages, storytotell.org, James Hague, etc.

--

5. This is how I got slightly obsessed with programming languages. As if the right language
   could make programming easy. Hint: That will never happen. But you'll note a bunch of fighting
   and excitement about PLs. It's mostly fashion. There are two interesting things to note though ...
   > See: Paradigms - OO vs FP vs Logic, etc. Static vs Dynamic divide/Types debate, etc.

--

6. I've come to believe that explorable, reflective *dynamic* systems, and *metaprogramming*
   are the computing world I want. Because I think software is ... pretty soft, mostly informal.
   > See: Wanting Types, Demanding Mirrors. Informality Sans Mysticism.

---

## tl;dr

This stuff won't help you get a job. But I think it might make you happy.

It at least is a big part of what keeps me interested in this field.

--

  * (But also why my frontend skillz are awful.)

--

Takeaways:

1. Do _Weird_ Shit (non-web stuff, art projects)
   > See: prosaic, cl-6502? (find better examples)

--

2. Investigate new ways of thinking about problem solving
   > See: Your nearest Algorithms or AI or Programming Languages textbook, Papers from the 70s

--

3. Read interesting code. (*Confession:* I'm terrible about this.)
   > See: ~/projects/reading?

--

That's it. **Thanks for being such awesome students!**

---

## Q & A

*Postwork* recommendations for books, blog articles, and
videos are going to be written up and posted.

Hopefully this weekend.

--

### DEMO THINGS

* Apropos, Describe, Dribble, Trace, Time, Disassemble

--

* Slime jump to definition, callees, callers, etc.

--

* Show live function redefinition, discuss `change-class`, smalltalk's `become`

--

* Show macros and macroexpansion?

--

* Grab that recent malisper article and show break and frame restarting?
